/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package stroom.analytics.demo.eventgen;

import stroom.analytics.demo.eventgen.beans.*;

import java.io.*;
import java.time.Instant;
import java.time.ZoneId;
import java.time.ZoneOffset;
import java.time.ZonedDateTime;
import java.time.format.DateTimeFormatter;
import java.time.temporal.ChronoField;
import java.util.*;

import com.fasterxml.jackson.databind.ObjectMapper;

import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;

public class EventGen {
    private final static String SEPARATOR = ", ";
    private final static String SPECIAL_EVENTS_WRITER_KEY = "_Special_";
    private final static String DEFAULT_SPECIAL_EVENT_FILENAME = "specialEvents.out";
    private final static String FILEEXTENSION = ".txt";
    private final static int DAY_SECS = 86400;

    private final Global config;
    private final Random random;

    private String timezone = "UTC";
    private long processingMs;


    private Map<Type, List<Instance>> instances = new HashMap<Type, List<Instance>>();
    private Map<String, Type> types = new HashMap<>();

    private Map <String, EventStream> streams = new HashMap<>();

    private Map <String, Schedule> schedules = new HashMap<>();

    private Map <String, PrintWriter> writers = new HashMap<>();

    public EventGen (Global config) throws IOException{
        this.config = config;

        if (config.getRunDays() <= 0){
            throw new IllegalArgumentException("runDays property must be defined");
        }

        initSchedules();
        initStreams ();
        initIdentities();

        if (config.getStartAt() != null){
            processingMs = config.getStartAt().getTime();
        } else {
            processingMs = System.currentTimeMillis() - (config.getRunDays() * DAY_SECS * 1000);
        }

        if (config.getTimezone() != null)
            timezone = config.getTimezone();

        random = new Random(config.getRandomSeed());
    }


    public void start (){
        createInstances();

        for (int day = 1; day <= config.getRunDays(); day++){
            System.out.println("Processing day " + day + " of " + config.getRunDays() + " a " +
                    Schedule.DAY_NAMES[getCurrentDayNum() - 1]);
            showInstanceCounts();
            processDay();
        }

        closeStreams();
    }

    private void showInstanceCounts (){
        for (Type type : instances.keySet()){
            Map <String, Integer> stateCounts = new HashMap<>();
            List<Instance> instancesOfType = instances.get(type);
            for (Instance instance : instancesOfType){
                int count = 1;
                if (stateCounts.containsKey(instance.getState()))
                    count += stateCounts.get(instance.getState());
                stateCounts.put(instance.getState(), count);
            }

            StringBuffer buffer = new StringBuffer();
            buffer.append("Instances of type " + type.getName() + " - ");
            for (String stateName : stateCounts.keySet()){
                buffer.append(stateName);
                buffer.append (":");
                buffer.append(stateCounts.get(stateName));
                buffer.append("    ");
            }

            System.out.println(buffer.toString());
        }
    }

    private void initIdentities(){
        for (Type type : config.getTypes()){
            types.put(type.getName(), type);
        }
    }

    private void initStreams() throws IOException {
        String outputDir = ".";

        if (config.getWorkingDirectory() == null){
            System.err.println("INFO: workingDirectory not specified, using current directory");
        } else {
            //Create the path if it doesn't exist
            outputDir = config.getWorkingDirectory();
            File file = new File (outputDir);
            if(!file.exists())
                file.mkdirs();
        }

        for (EventStream stream : config.getStreams()){
            streams.put(stream.getName(), stream);

            String filename = outputDir + "/" + stream.getStroomFeed() + FILEEXTENSION;

            PrintWriter writer = new PrintWriter(new BufferedWriter(new FileWriter(filename)));

            writers.put(stream.getName(), writer);
        }

        String specialFilepath = outputDir + "/" + DEFAULT_SPECIAL_EVENT_FILENAME;
        if (config.getSpecialEventFile() == null){
            System.err.println("INFO: specialEventFile property not defined, using default " + DEFAULT_SPECIAL_EVENT_FILENAME);
        } else {
            specialFilepath = outputDir + "/" + config.getSpecialEventFile();
        }

        PrintWriter writer = new PrintWriter(new BufferedWriter(new FileWriter(specialFilepath)));

        writers.put(SPECIAL_EVENTS_WRITER_KEY, writer);
    }

    private void initSchedules(){
        for (Schedule schedule : config.getSchedules()){
            schedules.put(schedule.getName(), schedule);
        }
    }


    private void processDay (){
        boolean shownMidnightCounts = false;

        long dayStart = processingMs;
        for (int sec = 0; sec < DAY_SECS; sec++){
            processingMs = dayStart + sec * 1000;

            generateEvents ();

            if (!shownMidnightCounts && getCurrentHourNum() == 0){
                System.out.println("and at midnight that day...");
                showInstanceCounts();
                shownMidnightCounts = true;
            }
        }
    }



    private void closeStreams(){
        for (PrintWriter writer : writers.values()){
            writer.close();
        }
    }

    private int getCurrentDayNum(){
        Instant instant = Instant.ofEpochMilli(processingMs);
        return instant.atZone(ZoneId.of(timezone)).get(ChronoField.DAY_OF_WEEK);
    }
    private int getCurrentHourNum(){
        Instant instant = Instant.ofEpochMilli(processingMs);
        return instant.atZone(ZoneId.of(timezone)).get(ChronoField.HOUR_OF_DAY);
    }

    private void generateEvents(){
        for (Type type : instances.keySet()){
            for (Instance instance : instances.get(type)){
                if (instance.getState() != null){
                    State state = type.getState(instance.getState());

                    if (state == null)
                        throw new IllegalArgumentException("No state called " + instance.getState() + " has been defined");

                    if (state.getTransitions() == null)
                        continue;

                    for (Transition transition : state.getTransitions()){
                        float halfLife = transition.getHalfLifeSecs();

                        if (transition.getSchedule() != null){
                            Schedule schedule = schedules.get(transition.getSchedule());
                            if (schedule == null){
                                throw new IllegalArgumentException("No schedule with name " + transition.getSchedule() + " is defined");
                            }

                            halfLife = halfLife / schedule.getValsForHourOfWeek(getCurrentDayNum(),getCurrentHourNum());
                        }

                        if (hasDecayedInUnitTime(random, halfLife))
                        {
                            fireEvent (instance, transition);
                            break;
                        }
                    }

                }
            }
        }
    }

    public static boolean hasDecayedInUnitTime (Random random, double halfLife){
        double maxValForDecay = 0.693 / halfLife;

        return (random.nextDouble() <= maxValForDecay);
    }

    private void fireEvent (Instance instance, Transition transition) {
        StringBuilder builder = new StringBuilder();

        builder.append(ZonedDateTime.ofInstant(Instant.ofEpochMilli(processingMs),
                ZoneOffset.UTC).format(DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'")));
        builder.append(SEPARATOR);

        builder.append(transition.getName());

        EventStream stream = streams.get(transition.getEventStream());
        if (stream == null) {
            //Default when no stream is defined is to only log the instance to the special events file (if required)
            builder.append(SEPARATOR);
            builder.append(instance.getName());
        } else if (stream.getIdentifiedObjects() != null) {
            for (String field : stream.getIdentifiedObjects()) {
                builder.append(SEPARATOR);
                if (field.equals(instance.getType().getName())) {
                    builder.append(instance.getName());
                } else {
                    boolean perfectAffinity = transition.isPerfectAffinity();
                    String otherInstance = findRelatedInstance(instance, field, perfectAffinity);
                    builder.append(otherInstance);
                }
            }
        }

        if (transition.getEventStream() != null) {
            PrintWriter writer = writers.get(transition.getEventStream());
            writer.println(builder.toString());
            writer.flush();
        }

        if (transition.getRecordSpecialEventAs() != null) {
            writers.get(SPECIAL_EVENTS_WRITER_KEY).println(transition.getRecordSpecialEventAs() + SEPARATOR + builder.toString());
            writers.get(SPECIAL_EVENTS_WRITER_KEY).flush();
        }


        if (transition.getTo() != null) {
            if (instance.getType().getState(transition.getTo()) == null)
                throw new IllegalArgumentException("Error in definition of " + transition.getName() + " - no state called "
                        + transition.getTo() + " has been defined");
            instance.setState(transition.getTo());
        }
    }

    private String findRelatedInstance (Instance instance, String otherTypeName, boolean perfectAffinity){

        Instance exisitingAffinitity = null;

        Type associatedType = types.get(otherTypeName);
        if (instance.getAffinities().containsKey(associatedType)){
            Affinity affinity = instance.getType().getAffinity(otherTypeName);
            exisitingAffinitity = instance.getAffinities().get(associatedType);
            if (perfectAffinity || random.nextFloat() <= affinity.getStrength())
                return exisitingAffinitity.getName();
        }


        //Check whether there's an affinity the other direction.
        Affinity affinity = associatedType.getAffinity(instance.getType().getName());
        Instance toAssociate = null;
        if (affinity != null){
            Instance existing = null;
            List<Instance> allOfThatType = instances.get(associatedType);
            for (Instance instanceOfThatType : allOfThatType){
                if (instanceOfThatType.equals(exisitingAffinitity))
                    continue;

                Instance to = instanceOfThatType.getAffinities().get(instance.getType());

                if (instance.equals(to)) {
                    if  (random.nextFloat() <= affinity.getStrength()) {
                        toAssociate = instanceOfThatType;

//                        System.out.println(">>>Reassociating " + instance.getName() + " with " + instanceOfThatType.getName());
                        break;
                    }
                }
            }
        }

        if (toAssociate == null){
            int numberOfInstances = associatedType.getCount();
            toAssociate = instances.get(associatedType).get(random.nextInt(numberOfInstances));
            instance.getAffinities().put(associatedType, toAssociate);
            if (affinity != null){
                toAssociate.getAffinities().put(instance.getType(), instance);
            }
        }

        return toAssociate.getName();
    }

    private void createInstances(){
        for (int type = 0; type < config.getTypes().length; type++){
            Type thisType = config.getTypes()[type];
            List<Instance> theseInstances = new ArrayList<>();
            instances.put(thisType, theseInstances);
            for (int instance = 1; instance <= thisType.getCount(); instance++){
                Instance thisInstance = new Instance(thisType, thisType.getName() + instance);
                theseInstances.add(thisInstance);
                if (thisType.getStates() != null){
                    String state = chooseInitialState (thisType.getStates());
                    thisInstance.setState(state);
                }
            }
        }
    }

    private String chooseInitialState (State[] states){
        float val = random.nextFloat();
        float minVal = 0.0f;
        for (int s = 0; s < states.length; s++){
            float maxVal = minVal + states[s].getInitialLikelihood();
            if (val <= maxVal)
                return states[s].getName();
            minVal = maxVal;
        }
        throw new IllegalArgumentException("State initial likelihood doesn't add up to 1.0");
    }

    public static void main(String[] args) {

        if (args.length != 1){
            System.out.println ("Usage: EventGen <config yaml file>");
            System.exit(1);
        }

        ObjectMapper mapper = new ObjectMapper(new YAMLFactory());

        try {
            File configFile = new File (args[0]);
            if (!configFile.exists()) {
                ClassLoader loader = Thread.currentThread().getContextClassLoader();
                if (loader.getResource(args[0]) != null)
                    configFile = new File(loader.getResource(args[0]).getFile());
            }

            if (!configFile.exists()){
                System.err.println ("FATAL: Unable to read file " + args[0]);
                System.exit(2);
            }

            Global global = mapper.readValue(configFile, Global.class);

            EventGen eventGen = new EventGen(global);

            eventGen.start();

        } catch (Exception e) {

            // TODO Auto-generated catch block

            e.printStackTrace();

        }

    }
}
